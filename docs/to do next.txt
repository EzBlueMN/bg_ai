1ï¸âƒ£ Event system
What the feature requires

State changes can be observed, recorded, replayed

Game logic does not mutate state silently

Your current situation (from sync)

You have:

match_history

Explicit game loop

But:

State transitions are procedural, not event-driven

Validation

âš ï¸ Interface-level adjustment needed

âŒ Not safe to bolt on later if state mutates freely

Minimal requirement (no implementation)

A conceptual event emitted on:

action chosen

state transition

terminal resolution

ğŸ‘‰ Action now: reserve an Event abstraction or hook
ğŸ‘‰ Implementation later: OK

2ï¸âƒ£ Replay / Time Travel
What the feature requires

Ability to:

reconstruct past states

replay deterministically

Either:

immutable states + events

or reversible transitions

Your current situation

State is:

mutable

passed around directly

History exists, but as log, not as driver

Validation

âš ï¸ Needs early constraint

âŒ Hard to retrofit if state mutation is unrestricted

Minimal requirement

Treat state as:

append-only OR

reconstructible from events

ğŸ‘‰ Action now: avoid hidden mutation
ğŸ‘‰ No need to implement replay yet

3ï¸âƒ£ Deterministic experiment
What the feature requires

Same seed â†’ same outcome

RNG must be:

explicit

owned

serializable

Your current situation

You already:

pass seeds

avoid global randomness (good)

Some policies still rely on:

implicit random

Validation

âœ… Mostly safe

âš ï¸ Small discipline required

Minimal requirement

RNG must be:

injected

never global

never implicit

ğŸ‘‰ Action now: policy API must accept RNG/context
ğŸ‘‰ No refactor needed

4ï¸âƒ£ Policy composition
What the feature requires

Policies that:

call other policies

delegate decisions

chain or pipeline logic

Your current situation

Policies are:

first-class

stateless or lightly stateful

choose(state, legal_actions) is clean

Validation

âœ… Architecture-ready

No blocking assumptions

Minimal requirement

Policy interface must:

allow calling other policies

not assume exclusivity

ğŸ‘‰ Safe now, safe later

5ï¸âƒ£ Partial information
What the feature requires

Distinction between:

true game state

player-observed state

Policies must not access full state implicitly

Your current situation

Policies receive:

full state

No separation between:

omniscient vs observed

Validation

âš ï¸ Critical architectural constraint

âŒ Very hard to retrofit cleanly

Minimal requirement

Policies must consume:

a view of the state

not the raw state object

ğŸ‘‰ Action now: introduce concept of StateView or equivalent
ğŸ‘‰ Implementation later: fine

6ï¸âƒ£ Multiplayer
What the feature requires

N players

Non-binary turns

Possibly simultaneous actions

Your current situation

Already supports:

player_id

list of agents

Turn logic is:

flexible enough

Validation

âœ… Safe

No forced 2-player assumptions found

ğŸ‘‰ No action required now