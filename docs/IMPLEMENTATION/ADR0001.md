# IMPLEMENTATION — ADR0001 (MVP)

**ADR:** 0001 — Event-traced deterministic architecture  
**Status:** Implemented (S1–S8 complete)  
**Goal:** Provide a human-friendly explanation of what ADR0001 added to the codebase.

---

## 1) What ADR0001 achieved (high-level)

ADR0001 implemented a minimal but complete engine foundation that supports:

- deterministic match execution (seeded RNG)
- event tracing for everything the engine does
- live play via Agent/Policy decisions
- replaying the match outcome from recorded events (no policies)

This gives a stable base for more features like:
- stats/query layer (ADR0002)
- tournaments / simulations
- persistence
- GUI or CLI tools

---

## 2) What was implemented (by slice)

### S1 — Repo bootstrap
**Outcome:** project runs as a Python package.

Key file:
- `src/bg_ai/cli/main.py`

---

### S2 — Deterministic RNG service
**Outcome:** deterministic RNG with **scoped forks**.

Key file:
- `src/bg_ai/engine/rng.py`

Important behavior:
- `RNG.from_seed(seed)` creates the root RNG
- `rng.fork("scope")` creates stable independent streams
- Adding a new scope does not change existing scopes

---

### S3 — Event model + in-memory sink
**Outcome:** canonical event envelope + a simple sink to store events.

Key files:
- `src/bg_ai/events/model.py`
- `src/bg_ai/events/sink.py`

Event envelope fields (MVP):
- match_id
- idx (monotonic)
- tick
- type
- payload
- schema_version (default 1)

---

### S4 — JSONL export/import
**Outcome:** ability to export/import event streams.

Key file:
- `src/bg_ai/events/codecs_jsonl.py`

Format:
- JSONL = 1 JSON object per line
- stable ordering = ordering in sink

---

### S5 — Game contract + MatchRunner lifecycle/ticks
**Outcome:** tick-based match loop that emits lifecycle events.

Key files:
- `src/bg_ai/games/base.py`
- `src/bg_ai/engine/match_runner.py`

Engine events added:
- `seed_set`
- `match_start`
- `tick_start`
- `tick_end`
- `match_end`

---

### S6 — Agent/Policy decisions
**Outcome:** policies generate actions and the engine records decisions.

Key files:
- `src/bg_ai/agents/agent.py`
- `src/bg_ai/policies/base.py`
- `src/bg_ai/policies/random_policy.py`
- `src/bg_ai/policies/fixed_policy.py`
- `src/bg_ai/engine/match_runner.py` (decision wiring)

Engine events added:
- `decision_requested`
- `decision_provided`
- `actions_applied`

Notes:
- The engine calls `game.legal_actions(state, actor_id)`
- The policy chooses from that list

---

### S7 — Example game: Rock Paper Scissors (RPS)
**Outcome:** a real game implementation to prove end-to-end behavior.

Key files:
- `src/bg_ai/games/rock_paper_scissors/types.py`
- `src/bg_ai/games/rock_paper_scissors/game.py`

RPS properties:
- two actors: A and B
- simultaneous decisions per tick
- terminal after N rounds
- emits one `domain_event` per round (optional for engine)

---

### S8 — Replay without policies
**Outcome:** reconstruct match result from event stream without policy calls.

Key file:
- `src/bg_ai/replay/replayer.py`

Replay rules (MVP):
- reads `seed_set`
- reads all `decision_provided` events (tick + actor_id + action)
- replays by calling `game.apply_actions(...)`
- returns `game.result(...)`

---

## 3) Event types (summary)

### Lifecycle
- `seed_set`
- `match_start`
- `match_end`

### Tick loop
- `tick_start`
- `tick_end`

### Decisions (live only)
- `decision_requested`
- `decision_provided`

### State advancement
- `actions_applied`

### Domain (game specific)
- `domain_event`

---

## 4) What ADR0001 intentionally did NOT implement

These were intentionally skipped to keep MVP small:

- simulation/tournament runner
- stats/query layer across matches (ADR0002)
- persistence layer / DB
- strict replay validation (detect mismatch between events and state)
- snapshots (performance)
- plugin registry for games/policies
- CLI argument parsing/config system
- GUI

---

## 5) How to debug ADR0001 behavior

### "Match never ends"
Look at:
- `game.is_terminal(state)`
- `MatchConfig.max_ticks`

### "Actions seem wrong"
Look at:
- `game.legal_actions(...)`
- `policy.decide(...)`
- `MatchRunner.run_match(...)` decision loop

### "Replay != live"
Look at:
- event stream contains all `decision_provided`
- replay applies actions in correct tick order
- game.apply_actions uses only:
  - provided actions
  - deterministic RNG (forked by tick)

---

## 6) How to extend ADR0001 safely

When adding new features:
1) prefer adding new event types rather than hidden side effects
2) keep policies stateless unless explicitly designed otherwise
3) keep determinism by using the RNG service (never global random)
4) keep replay possible by ensuring decisions are recorded

---

## 7) Next step

Proceed with ADR0002:
- Stats/Query layer (in-memory derived views over matches/events)
